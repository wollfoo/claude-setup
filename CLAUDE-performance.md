# CLAUDE-performance.md

**Performance Optimization** (t·ªëi ∆∞u hi·ªáu su·∫•t ‚Äì benchmarks, optimization strategies, resource usage patterns)

## üìä Performance Metrics

### **Response Time Benchmarks** (ƒêi·ªÉm chu·∫©n th·ªùi gian)

**Tool Execution Times** (th·ªùi gian th·ª±c thi c√¥ng c·ª•):
```yaml
Read:
  small_file: "< 100ms"     # < 1KB
  medium_file: "< 500ms"    # 1-100KB
  large_file: "< 2000ms"    # 100KB-10MB
  target_sla: "< 1000ms"    # 95th percentile

Edit:
  simple_edit: "< 200ms"    # Single line
  multi_edit: "< 800ms"     # Multiple changes
  large_file: "< 3000ms"    # > 1MB
  target_sla: "< 1500ms"

Bash:
  simple_cmd: "< 500ms"     # ls, pwd, echo
  git_ops: "< 2000ms"       # status, commit
  build: "< 30000ms"        # npm install
  target_sla: "< 5000ms"

Grep:
  small_codebase: "< 300ms"   # < 100 files
  medium_codebase: "< 1000ms" # 100-1000 files
  large_codebase: "< 5000ms"  # > 1000 files
  target_sla: "< 2000ms"
```

### **Resource Utilization Metrics** (Ch·ªâ s·ªë t√†i nguy√™n)

**Memory Usage Patterns** (m·∫´u s·ª≠ d·ª•ng b·ªô nh·ªõ):
- **Baseline** (c∆° s·ªü): 200-500MB typical
- **Peak** (ƒë·ªânh): < 2GB recommended
- **Leak Detection** (ph√°t hi·ªán r√≤ r·ªâ): Growth > 100MB/hour = alert

**CPU Usage Patterns** (m·∫´u s·ª≠ d·ª•ng CPU):
- **Idle** (nh√†n r·ªói): < 5%
- **Normal Operations** (ho·∫°t ƒë·ªông b√¨nh th∆∞·ªùng): 10-30%
- **Peak Load** (t·∫£i ƒë·ªânh): < 70%

## ‚ö° Optimization Strategies

### **1. Token Usage Optimization** (T·ªëi ∆∞u token)

**Context Management** (qu·∫£n l√Ω ng·ªØ c·∫£nh):
```typescript
// **Context Size Monitoring** (gi√°m s√°t k√≠ch th∆∞·ªõc)
const MAX_CONTEXT_SIZE = 100_000; // 100KB limit

function optimizeContext(context: string): string {
  if (context.length > MAX_CONTEXT_SIZE) {
    // **Summarize Old Content** (t√≥m t·∫Øt n·ªôi dung c≈©)
    const summary = summarizeOldContext(context);
    // **Keep Recent** (gi·ªØ n·ªôi dung g·∫ßn)
    const recent = context.slice(-50_000);
    return `${summary}\n--- Recent ---\n${recent}`;
  }
  return context;
}
```

**Smart Content Loading** (t·∫£i th√¥ng minh):
```typescript
// **Selective Reading** (ƒë·ªçc c√≥ ch·ªçn l·ªçc)
function smartFileRead(filePath: string, maxLines = 2000): string {
  const totalLines = getLineCount(filePath);
  if (totalLines > maxLines) {
    return readLines(filePath, 0, maxLines) + "\n... [truncated] ...";
  }
  return readFile(filePath);
}

// **Intelligent Grep** (grep th√¥ng minh)
function smartGrep(pattern: string, path: string, maxResults = 50): string[] {
  const results = grep(pattern, path);
  if (results.length > maxResults) {
    return results.slice(0, maxResults).concat([
      `... ${results.length - maxResults} more matches. Refine pattern ...`
    ]);
  }
  return results;
}
```

### **2. Network Performance** (Hi·ªáu su·∫•t m·∫°ng)

**Connection Pooling** (g·ªôp k·∫øt n·ªëi):
```typescript
// **HTTP Pool Configuration** (c·∫•u h√¨nh pool)
const httpConfig = {
  poolSize: 10,
  poolTimeout: 30000,
  keepAlive: true,
  retryCount: 3,
  retryDelay: 1000
};
```

**Caching Strategies** (chi·∫øn l∆∞·ª£c cache):
```typescript
// **Web Fetch Cache** (cache web)
class WebFetchCache {
  private cache = new Map<string, { data: string; timestamp: number }>();
  private ttl = 900_000; // 15 minutes

  async fetch(url: string): Promise<string> {
    const cached = this.cache.get(url);
    if (cached && Date.now() - cached.timestamp < this.ttl) {
      return cached.data; // **Cache Hit** (tr√∫ng cache)
    }

    // **Cache Miss** (tr∆∞·ª£t cache) - fetch v√† store
    const data = await httpFetch(url);
    this.cache.set(url, { data, timestamp: Date.now() });
    return data;
  }
}

// **Grep Result Cache** (cache k·∫øt qu·∫£ grep)
class GrepCache {
  private cache = new Map<string, string[]>();
  private ttl = 300_000; // 5 minutes

  search(pattern: string, dir: string): string[] {
    const key = `${pattern}|${dir}`;
    const cached = this.cache.get(key);

    if (cached && !this.directoryChanged(dir)) {
      return cached;
    }

    const results = grep(pattern, dir);
    this.cache.set(key, results);
    return results;
  }
}
```

**Rate Limiting** (gi·ªõi h·∫°n t·ªëc ƒë·ªô):
```typescript
// **API Rate Limiter** (gi·ªõi h·∫°n API)
class RateLimiter {
  private requestsPerMinute = 60;
  private requests: number[] = [];

  async execute<T>(fn: () => Promise<T>): Promise<T> {
    const now = Date.now();
    // **Clean Old Requests** (x√≥a requests c≈©)
    this.requests = this.requests.filter(t => now - t < 60000);

    if (this.requests.length >= this.requestsPerMinute) {
      // **Wait for Next Window** (ƒë·ª£i window ti·∫øp)
      await sleep(60000 - (now - this.requests[0]));
    }

    this.requests.push(now);
    return fn();
  }
}
```

## üîß System Optimization

### **1. File System Performance** (Hi·ªáu su·∫•t file system)

**I/O Optimization Patterns** (m·∫´u t·ªëi ∆∞u I/O):
```bash
# **Mount Options** (t√πy ch·ªçn mount)
noatime,nodiratime  # Disable access time updates

# **Read-Ahead** (ƒë·ªçc tr∆∞·ªõc)
256KB optimal for most workloads

# **File Descriptor Limits** (gi·ªõi h·∫°n file descriptor)
ulimit -n 65536  # Increase for high concurrency
```

**Temporary File Management** (qu·∫£n l√Ω file t·∫°m):
```typescript
// **Use Memory-Backed Storage** (d√πng b·ªô nh·ªõ)
const TEMP_DIR = '/dev/shm/claude-temp'; // tmpfs for speed

// **Auto-Cleanup** (t·ª± ƒë·ªông d·ªçn d·∫πp)
function cleanupTempFiles(olderThanHours = 24) {
  const cutoff = Date.now() - (olderThanHours * 3600 * 1000);
  // Remove files older than cutoff
}
```

**File Access Patterns** (m·∫´u truy c·∫≠p):
```typescript
// **Preload Common Files** (t·∫£i tr∆∞·ªõc files th∆∞·ªùng d√πng)
const COMMON_FILES = [
  'package.json',
  'README.md',
  'CLAUDE.md',
  'tsconfig.json'
];

function preloadFiles() {
  COMMON_FILES.forEach(file => {
    if (exists(file)) {
      readFile(file); // **Warm Cache** (l√†m n√≥ng cache)
    }
  });
}
```

### **2. Memory Management** (Qu·∫£n l√Ω b·ªô nh·ªõ)

**Memory Pool Configuration** (c·∫•u h√¨nh memory pool):
```bash
# **System Settings** (c√†i ƒë·∫∑t h·ªá th·ªëng)
vm.swappiness = 10              # Minimize swapping
vm.overcommit_memory = 1        # Allow overcommit
vm.overcommit_ratio = 80        # 80% physical RAM

# **Process Limits** (gi·ªõi h·∫°n process)
soft_limit: 2GB
hard_limit: 4GB
```

**Garbage Collection** (thu gom r√°c):
```typescript
// **Node.js GC Tuning** (ƒëi·ªÅu ch·ªânh GC)
process.env.NODE_OPTIONS = '--max-old-space-size=2048 --gc-interval=100';

// **Force GC Periodically** (√©p GC ƒë·ªãnh k·ª≥)
if (global.gc) {
  setInterval(() => {
    if (getMemoryUsage() > THRESHOLD) {
      global.gc(); // **Manual Collection** (thu gom th·ªß c√¥ng)
    }
  }, 60000); // Every minute
}
```

## üìà Performance Monitoring

### **Real-time Monitoring** (Gi√°m s√°t th·ªùi gian th·ª±c)

**System Metrics** (ch·ªâ s·ªë h·ªá th·ªëng):
```typescript
interface PerformanceMetrics {
  cpu_percent: number;      // **CPU Usage** (s·ª≠ d·ª•ng CPU)
  memory_mb: number;        // **Memory Usage** (s·ª≠ d·ª•ng b·ªô nh·ªõ)
  disk_percent: number;     // **Disk Usage** (s·ª≠ d·ª•ng ƒëƒ©a)
  response_time_ms: number; // **Response Time** (th·ªùi gian ph·∫£n h·ªìi)
}

// **Monitoring Dashboard** (b·∫£ng gi√°m s√°t)
function generateDashboard(metrics: PerformanceMetrics) {
  const status = {
    cpu: metrics.cpu_percent < 60 ? 'good' :
         metrics.cpu_percent < 80 ? 'warning' : 'critical',
    memory: metrics.memory_mb < 1024 ? 'good' :
            metrics.memory_mb < 1536 ? 'warning' : 'critical'
  };
  return status;
}
```

**Alert System** (h·ªá th·ªëng c·∫£nh b√°o):
```typescript
// **Alert Thresholds** (ng∆∞·ª°ng c·∫£nh b√°o)
const THRESHOLDS = {
  cpu_percent: 80,
  memory_mb: 1536,
  disk_percent: 90,
  response_time_ms: 5000,
  error_rate_percent: 5
};

// **Alert Handler** (x·ª≠ l√Ω c·∫£nh b√°o)
function performanceAlert(metric: string, value: number, threshold: number) {
  const message = `Alert: ${metric} = ${value} (threshold: ${threshold})`;

  // **Send Notification** (g·ª≠i th√¥ng b√°o)
  sendEmail(message);
  sendSlack(message);
  logAlert(message);
}
```

### **Historical Analysis** (Ph√¢n t√≠ch l·ªãch s·ª≠)

**Performance Trends** (xu h∆∞·ªõng hi·ªáu su·∫•t):
```typescript
// **Report Generation** (t·∫°o b√°o c√°o)
interface PerformanceReport {
  period: 'daily' | 'weekly' | 'monthly';
  response_times: {
    tool: string;
    avg_ms: number;
    min_ms: number;
    max_ms: number;
    call_count: number;
  }[];
  resource_usage: {
    avg_cpu_percent: number;
    avg_memory_mb: number;
  };
}

// **Capacity Planning** (k·∫ø ho·∫°ch nƒÉng l·ª±c)
function capacityPlanning(currentLoad: number, growthRate = 0.2) {
  const projections = [];
  for (let month = 1; month <= 6; month++) {
    const projected = currentLoad * Math.pow(1 + growthRate, month);
    projections.push({ month, load: Math.round(projected) });
  }
  return projections;
}
```

## üéØ Optimization Recommendations

### **Configuration Best Practices** (th·ª±c h√†nh t·ªët nh·∫•t)

**Optimal Settings** (c√†i ƒë·∫∑t t·ªëi ∆∞u):
```json
{
  "performance": {
    "bash_timeout": 120000,
    "max_output_tokens": 4096,
    "context_window": 100000,
    "rate_limit_rpm": 60,
    "cache_ttl_seconds": 900,
    "max_concurrent_ops": 5
  },
  "resource_limits": {
    "max_memory_mb": 2048,
    "max_cpu_percent": 70,
    "max_file_size_mb": 10,
    "max_context_size_kb": 100
  },
  "optimization": {
    "enable_caching": true,
    "enable_compression": true,
    "enable_parallel": true,
    "smart_context_mgmt": true
  }
}
```

### **Performance Checklist** (danh s√°ch ki·ªÉm tra)

1. ‚úÖ **Context Size** (k√≠ch th∆∞·ªõc ng·ªØ c·∫£nh): < 100KB
2. ‚úÖ **Batch Operations** (g·ªôp thao t√°c): Multiple ops when possible
3. ‚úÖ **Network Caching** (cache m·∫°ng): TTL 15 min for repeated requests
4. ‚úÖ **Memory Monitoring** (gi√°m s√°t b·ªô nh·ªõ): Check for leaks regularly
5. ‚úÖ **Parallel Processing** (x·ª≠ l√Ω song song): Independent tasks
6. ‚úÖ **Resource Limits** (gi·ªõi h·∫°n t√†i nguy√™n): Enforce hard limits
7. ‚úÖ **Performance Profiling** (l·∫≠p profile): Regular benchmarking

### **Troubleshooting Guide** (h∆∞·ªõng d·∫´n kh·∫Øc ph·ª•c)

**Common Issues** (v·∫•n ƒë·ªÅ th∆∞·ªùng g·∫∑p):

**Slow Response Times** (ph·∫£n h·ªìi ch·∫≠m):
- Check context size ‚Üí Optimize if > 100KB
- Enable caching ‚Üí TTL 15 minutes
- Reduce file read sizes ‚Üí Use smart loading

**High Memory Usage** (b·ªô nh·ªõ cao):
- Force garbage collection ‚Üí Manual GC trigger
- Clear old contexts ‚Üí Cleanup > 1 hour old
- Check for leaks ‚Üí Monitor growth rate

**CPU Spikes** (CPU tƒÉng ƒë·ªôt ng·ªôt):
- Review concurrent operations ‚Üí Limit to 5 max
- Optimize grep patterns ‚Üí Use specific patterns
- Enable rate limiting ‚Üí 60 req/min

---

**Performance optimization** (t·ªëi ∆∞u hi·ªáu su·∫•t) l√† **ongoing process** (quy tr√¨nh li√™n t·ª•c) requiring **regular monitoring** (gi√°m s√°t th∆∞·ªùng xuy√™n) v√† **adjustment** (ƒëi·ªÅu ch·ªânh) based on **usage patterns** (m·∫´u s·ª≠ d·ª•ng).
